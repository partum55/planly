<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Planly</title>
  <style>
    /* ─── Reset & Base ─────────────────────────────────── */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', sans-serif;
      background: transparent;
      overflow: hidden;
      user-select: none;
    }

    /* ─── Container ────────────────────────────────────── */
    .container {
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      height: 100vh;
      padding: 8px;
    }

    .chat-box {
      position: relative;
      background: #1a1a2e;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      box-shadow:
        0 24px 48px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      max-height: calc(100vh - 16px);
      backdrop-filter: blur(24px);
    }

    /* ─── Messages Area ────────────────────────────────── */
    .messages {
      display: none; /* hidden when empty */
      flex: 1;
      overflow-y: auto;
      padding: 16px 16px 8px;
      scroll-behavior: smooth;
    }

    .messages.has-messages {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .messages::-webkit-scrollbar { width: 4px; }
    .messages::-webkit-scrollbar-track { background: transparent; }
    .messages::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

    /* ─── Message Bubbles ──────────────────────────────── */
    .msg {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.5;
      word-wrap: break-word;
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .msg.user {
      align-self: flex-end;
      background: #6c5ce7;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .msg.agent {
      align-self: flex-start;
      background: #2d2d44;
      color: #e0e0e0;
      border-bottom-left-radius: 4px;
    }

    .msg.agent .typing-dots {
      display: inline-flex;
      gap: 4px;
    }

    .msg.agent .typing-dots span {
      width: 6px;
      height: 6px;
      background: #888;
      border-radius: 50%;
      animation: blink 1.4s infinite both;
    }
    .msg.agent .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .msg.agent .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes blink {
      0%, 80%, 100% { opacity: 0.3; }
      40% { opacity: 1; }
    }

    /* ─── Action Cards ─────────────────────────────────── */
    .action-cards {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }

    .action-card {
      background: #2d2d44;
      border: 1px solid rgba(108, 92, 231, 0.3);
      border-radius: 10px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .action-card:hover {
      border-color: #6c5ce7;
      background: #363650;
    }

    .action-card.selected {
      border-color: #6c5ce7;
      background: rgba(108, 92, 231, 0.15);
    }

    .action-card .check {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.25);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .action-card.selected .check {
      background: #6c5ce7;
      border-color: #6c5ce7;
    }

    .action-card.selected .check::after {
      content: '';
      width: 6px;
      height: 10px;
      border: solid #fff;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
      margin-bottom: 2px;
    }

    .action-card .info {
      flex: 1;
    }

    .action-card .tool-name {
      font-size: 12px;
      font-weight: 600;
      color: #a29bfe;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .action-card .desc {
      font-size: 13px;
      color: #ccc;
    }

    /* ─── Confirm Bar ──────────────────────────────────── */
    .confirm-bar {
      display: none;
      padding: 8px 16px 12px;
      gap: 8px;
      justify-content: flex-end;
    }

    .confirm-bar.visible {
      display: flex;
    }

    .confirm-bar button {
      padding: 8px 18px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-confirm {
      background: #6c5ce7;
      color: #fff;
    }
    .btn-confirm:hover { background: #5a4bd1; }

    .btn-cancel {
      background: rgba(255,255,255,0.06);
      color: #aaa;
    }
    .btn-cancel:hover { background: rgba(255,255,255,0.1); }

    /* ─── Calendar Picker ──────────────────────────────── */
    .picker-container {
      background: #2d2d44;
      border-radius: 10px;
      padding: 12px;
      width: 100%;
    }

    .picker-container label {
      display: block;
      font-size: 12px;
      color: #a29bfe;
      margin-bottom: 6px;
      font-weight: 500;
    }

    .picker-container input {
      width: 100%;
      padding: 8px 12px;
      background: #1a1a2e;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #e0e0e0;
      font-size: 14px;
      outline: none;
    }

    .picker-container input:focus {
      border-color: #6c5ce7;
    }

    .picker-submit {
      margin-top: 8px;
      padding: 6px 14px;
      background: #6c5ce7;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    /* ─── Result Items ─────────────────────────────────── */
    .result-item {
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      margin-top: 4px;
    }

    .result-item.success {
      background: rgba(0, 210, 106, 0.12);
      color: #00d26a;
    }

    .result-item.failure {
      background: rgba(255, 71, 87, 0.12);
      color: #ff4757;
    }

    /* ─── Input Area ───────────────────────────────────── */
    .input-area {
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .screenshot-btn {
      width: 34px;
      height: 34px;
      background: rgba(255,255,255,0.06);
      border: none;
      border-radius: 8px;
      color: #888;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .screenshot-btn:hover {
      background: rgba(108, 92, 231, 0.2);
      color: #a29bfe;
    }

    .input-area input {
      flex: 1;
      background: transparent;
      border: none;
      color: #e0e0e0;
      font-size: 14px;
      outline: none;
      padding: 8px 0;
    }

    .input-area input::placeholder {
      color: #555;
    }

    .send-btn {
      width: 34px;
      height: 34px;
      background: #6c5ce7;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
      opacity: 0.4;
      pointer-events: none;
    }

    .send-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    .send-btn.active:hover {
      background: #5a4bd1;
    }

    /* ─── Esc hint ─────────────────────────────────────── */
    .esc-hint {
      text-align: center;
      font-size: 10px;
      color: #444;
      padding: 0 0 6px;
    }

    /* ─── Drag Handle (title bar) ──────────────────────── */
    .drag-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 0 2px;
      cursor: grab;
      user-select: none;
      -webkit-app-region: no-drag; /* we handle dragging ourselves */
      flex-shrink: 0;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .drag-handle .grip {
      width: 36px;
      height: 4px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
      transition: background 0.15s;
    }

    .drag-handle:hover .grip {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ─── Resize Handles ───────────────────────────────── */
    .resize-handle {
      position: absolute;
      z-index: 100;
    }

    /* Edges */
    .resize-handle.rh-top    { top: -3px; left: 8px; right: 8px; height: 6px; cursor: n-resize; }
    .resize-handle.rh-bottom { bottom: -3px; left: 8px; right: 8px; height: 6px; cursor: s-resize; }
    .resize-handle.rh-left   { top: 8px; bottom: 8px; left: -3px; width: 6px; cursor: w-resize; }
    .resize-handle.rh-right  { top: 8px; bottom: 8px; right: -3px; width: 6px; cursor: e-resize; }

    /* Corners */
    .resize-handle.rh-top-left     { top: -3px; left: -3px; width: 12px; height: 12px; cursor: nw-resize; }
    .resize-handle.rh-top-right    { top: -3px; right: -3px; width: 12px; height: 12px; cursor: ne-resize; }
    .resize-handle.rh-bottom-left  { bottom: -3px; left: -3px; width: 12px; height: 12px; cursor: sw-resize; }
    .resize-handle.rh-bottom-right { bottom: -3px; right: -3px; width: 12px; height: 12px; cursor: se-resize; }
  </style>
</head>
<body>

<div class="container">
  <div class="chat-box" id="chatBox">
    <!-- Resize handles (edges + corners) -->
    <div class="resize-handle rh-top" data-direction="n"></div>
    <div class="resize-handle rh-bottom" data-direction="s"></div>
    <div class="resize-handle rh-left" data-direction="w"></div>
    <div class="resize-handle rh-right" data-direction="e"></div>
    <div class="resize-handle rh-top-left" data-direction="nw"></div>
    <div class="resize-handle rh-top-right" data-direction="ne"></div>
    <div class="resize-handle rh-bottom-left" data-direction="sw"></div>
    <div class="resize-handle rh-bottom-right" data-direction="se"></div>

    <!-- Drag handle (title bar) -->
    <div class="drag-handle" id="dragHandle" title="Drag to move window" tabindex="0" role="slider" aria-label="Drag to move window">
      <div class="grip"></div>
    </div>

    <div class="messages" id="messages"></div>
    <div class="confirm-bar" id="confirmBar">
      <button class="btn-cancel" id="btnCancelActions">Cancel</button>
      <button class="btn-confirm" id="btnConfirmActions">Confirm</button>
    </div>
    <div class="input-area">
      <button class="screenshot-btn" id="btnScreenshot" title="Take screenshot">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <rect x="1" y="3" width="14" height="10" rx="2" stroke="currentColor" stroke-width="1.5"/>
          <circle cx="8" cy="8" r="2.5" stroke="currentColor" stroke-width="1.5"/>
        </svg>
      </button>
      <input type="text" id="inputField" placeholder="Type a command... e.g. 'appoint dinner'" autofocus />
      <button class="send-btn" id="btnSend">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
          <path d="M1 7h10M8 4l3 3-3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>
    <div class="esc-hint">Esc to close</div>
  </div>
</div>

<script>
  // ─── State ──────────────────────────────────────────────
  let conversationId = null;
  let selectedActionIds = new Set();
  let currentActions = [];
  let lastScreenshot = null;
  let isProcessing = false;
  let currentAbortController = null; // issue 7b: timeout/cancellation

  // ─── DOM refs ───────────────────────────────────────────
  const messagesEl = document.getElementById('messages');
  const inputField = document.getElementById('inputField');
  const btnSend = document.getElementById('btnSend');
  const btnScreenshot = document.getElementById('btnScreenshot');
  const confirmBar = document.getElementById('confirmBar');
  const btnConfirmActions = document.getElementById('btnConfirmActions');
  const btnCancelActions = document.getElementById('btnCancelActions');

  // ─── Planly bridge (from preload) ──────────────────────
  const planlyApi = window.planly;

  // ─── Input handling ────────────────────────────────────
  inputField.addEventListener('input', () => {
    btnSend.classList.toggle('active', inputField.value.trim().length > 0);
  });

  inputField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && inputField.value.trim()) {
      handleSend();
    }
  });

  // Global Esc to close
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (window.planly) {
        window.planly.closeChat();
      }
    }
  });

  btnSend.addEventListener('click', () => {
    if (inputField.value.trim()) handleSend();
  });

  // ─── Screenshot button ─────────────────────────────────
  btnScreenshot.addEventListener('click', async () => {
    btnScreenshot.style.color = '#6c5ce7';
    try {
      lastScreenshot = await planlyApi.takeScreenshot();
      btnScreenshot.style.color = '#00d26a';
      setTimeout(() => { btnScreenshot.style.color = ''; }, 1500);
    } catch (err) {
      btnScreenshot.style.color = '#ff4757';
      setTimeout(() => { btnScreenshot.style.color = ''; }, 1500);
      reportError('screenshot', err);
    }
  });

  // ─── Confirm / Cancel actions ──────────────────────────
  btnConfirmActions.addEventListener('click', () => handleConfirmActions());
  btnCancelActions.addEventListener('click', () => {
    selectedActionIds.clear();
    confirmBar.classList.remove('visible');
    document.querySelectorAll('.action-card').forEach(c => c.classList.remove('selected'));
  });

  // ─── Reset on toggle (issues 3a, 3b) ───────────────────
  planlyApi.resetChat(() => {
    // Cancel any in-flight request
    if (currentAbortController) {
      currentAbortController.abort();
      currentAbortController = null;
    }
    conversationId = null;
    selectedActionIds.clear();
    currentActions = [];
    lastScreenshot = null;
    isProcessing = false;
    messagesEl.innerHTML = '';
    messagesEl.classList.remove('has-messages');
    confirmBar.classList.remove('visible');
    inputField.value = '';
    btnSend.classList.remove('active');
    requestResize();
  });

  // ─── Core: Send message ─────────────────────────────────
  async function handleSend() {
    if (isProcessing) return;
    const text = inputField.value.trim();
    if (!text) return;

    isProcessing = true;
    inputField.value = '';
    btnSend.classList.remove('active');

    addMessage('user', text);

    // If no screenshot taken yet, take one automatically
    if (!lastScreenshot) {
      addTypingIndicator();
      try {
        lastScreenshot = await planlyApi.takeScreenshot();
      } catch (err) {
        removeAllTypingIndicators();
        addMessage('agent', 'Failed to capture screenshot. Please try the camera button manually.');
        reportError('auto-screenshot', err);
        isProcessing = false;
        return;
      }
    }

    if (!document.querySelector('.typing-indicator')) {
      addTypingIndicator();
    }

    // Set up timeout (issue 7b)
    const abortController = { aborted: false };
    currentAbortController = abortController;
    const timeoutId = setTimeout(() => {
      if (!abortController.aborted) {
        abortController.aborted = true;
        removeAllTypingIndicators();
        addMessage('agent', 'Request timed out. Please try again.');
        isProcessing = false;
        currentAbortController = null;
      }
    }, 30000);

    try {
      // OCR via main process (issues 6a, 7a)
      const ocrResult = await planlyApi.runOCR(lastScreenshot.imageBase64);

      if (abortController.aborted) return;

      // Agent call via main process IPC (issue 1b — uses ApiClient with auto-refresh)
      const response = await planlyApi.agentProcess({
        conversation_id: conversationId,
        user_prompt: text,
        messages: ocrResult.messages,
        screenshot_metadata: {
          ocr_confidence: ocrResult.confidence,
          raw_text: ocrResult.rawText,
        },
      });

      clearTimeout(timeoutId);
      if (abortController.aborted) return;
      currentAbortController = null;

      removeAllTypingIndicators();

      // Validate response shape (issue 2a)
      if (!response || !response.conversation_id) {
        addMessage('agent', 'Received an unexpected response from the server.');
        reportError('agent:process', 'Missing conversation_id in response');
        return;
      }

      if (!response.blocks || !Array.isArray(response.blocks)) {
        addMessage('agent', 'Received an unexpected response format.');
        reportError('agent:process', 'Missing or invalid blocks array');
        conversationId = response.conversation_id;
        return;
      }

      conversationId = response.conversation_id;

      // Clear screenshot after successful use (issue 3a)
      lastScreenshot = null;

      renderBlocks(response.blocks);

    } catch (err) {
      clearTimeout(timeoutId);
      if (abortController.aborted) return;
      currentAbortController = null;

      removeAllTypingIndicators();
      const errMsg = err && err.message ? err.message : 'Unknown error';

      // Surface auth errors clearly (issue 4b)
      if (errMsg.includes('401') || errMsg.toLowerCase().includes('unauthorized')) {
        addMessage('agent', 'Your session has expired. Please log in again.');
      } else {
        addMessage('agent', 'Something went wrong: ' + errMsg);
      }
      reportError('handleSend', errMsg);
    } finally {
      isProcessing = false;
    }
  }

  // ─── Confirm actions ────────────────────────────────────
  async function handleConfirmActions() {
    if (selectedActionIds.size === 0) return;

    confirmBar.classList.remove('visible');
    addTypingIndicator();

    try {
      // Route through main process IPC (issue 1b)
      const response = await planlyApi.agentConfirm(
        conversationId,
        Array.from(selectedActionIds)
      );

      removeAllTypingIndicators();

      // Validate response (issue 2a)
      if (!response || !Array.isArray(response.results)) {
        addMessage('agent', 'Received an unexpected confirmation response.');
        reportError('agent:confirm', 'Invalid response shape');
        return;
      }

      for (const result of response.results) {
        const el = document.createElement('div');
        el.className = 'result-item ' + (result.success ? 'success' : 'failure');
        el.textContent = (result.success ? '\u2713 ' : '\u2717 ') + (result.tool || '') + ': ' +
          (result.success ? 'Done' : 'Failed');
        messagesEl.appendChild(el);
      }

      if (response.formatted_response) {
        addMessage('agent', response.formatted_response);
      }

      selectedActionIds.clear();
      currentActions = [];
      scrollToBottom();
      requestResize();
    } catch (err) {
      removeAllTypingIndicators();
      const errMsg = err && err.message ? err.message : 'Unknown error';
      addMessage('agent', 'Failed to execute actions: ' + errMsg);
      reportError('handleConfirmActions', errMsg);
    }
  }

  // ─── Render response blocks ─────────────────────────────
  function renderBlocks(blocks) {
    for (const block of blocks) {
      switch (block.type) {
        case 'text':
          if (block.content) addMessage('agent', block.content);
          break;

        case 'action_cards':
          if (Array.isArray(block.actions) && block.actions.length > 0) {
            renderActionCards(block.actions);
          }
          break;

        case 'calendar_picker':
          renderPicker('date', block.prompt || 'Pick a date');
          break;

        case 'time_picker':
          renderPicker('time', block.prompt || 'Pick a time');
          break;

        case 'error':
          addMessage('agent', block.message || 'An error occurred.');
          break;

        default:
          reportError('renderBlocks', 'Unknown block type: ' + block.type);
          break;
      }
    }

    scrollToBottom();
    requestResize();
  }

  function renderActionCards(actions) {
    currentActions = actions;
    selectedActionIds.clear();

    const wrapper = document.createElement('div');
    wrapper.className = 'action-cards';

    for (const action of actions) {
      if (!action || !action.action_id) continue; // skip malformed actions (issue 2a)

      const card = document.createElement('div');
      card.className = 'action-card';
      card.dataset.actionId = action.action_id;
      card.innerHTML = `
        <div class="check"></div>
        <div class="info">
          <div class="tool-name">${escapeHtml(action.tool || 'unknown')}</div>
          <div class="desc">${escapeHtml(action.description || '')}</div>
        </div>
      `;

      card.addEventListener('click', () => {
        card.classList.toggle('selected');
        if (card.classList.contains('selected')) {
          selectedActionIds.add(action.action_id);
        } else {
          selectedActionIds.delete(action.action_id);
        }
        confirmBar.classList.toggle('visible', selectedActionIds.size > 0);
      });

      wrapper.appendChild(card);
    }

    messagesEl.appendChild(wrapper);
    messagesEl.classList.add('has-messages');
    scrollToBottom();
    requestResize();
  }

  function renderPicker(type, prompt) {
    const container = document.createElement('div');
    container.className = 'picker-container';

    const inputType = type === 'date' ? 'date' : 'time';
    container.innerHTML = `
      <label>${escapeHtml(prompt)}</label>
      <input type="${inputType}" class="picker-input" />
      <button class="picker-submit">Set</button>
    `;

    const submitBtn = container.querySelector('.picker-submit');
    const pickerInput = container.querySelector('.picker-input');

    submitBtn.addEventListener('click', () => {
      const val = pickerInput.value;
      if (!val) return;
      container.remove();
      // Send the picked value as a user message
      inputField.value = val;
      handleSend();
    });

    messagesEl.appendChild(container);
    messagesEl.classList.add('has-messages');
    scrollToBottom();
    requestResize();
  }

  // ─── Helpers ────────────────────────────────────────────
  function addMessage(role, text) {
    const el = document.createElement('div');
    el.className = 'msg ' + role;
    el.textContent = text;
    messagesEl.appendChild(el);
    messagesEl.classList.add('has-messages');
    scrollToBottom();
    requestResize();
  }

  function addTypingIndicator() {
    // Remove any existing indicators first (issue 3c)
    removeAllTypingIndicators();
    const el = document.createElement('div');
    el.className = 'msg agent typing-indicator';
    el.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
    messagesEl.appendChild(el);
    messagesEl.classList.add('has-messages');
    scrollToBottom();
    requestResize();
  }

  function removeAllTypingIndicators() {
    // Remove ALL typing indicators, not just the first (issue 3c)
    document.querySelectorAll('.typing-indicator').forEach(el => el.remove());
  }

  function scrollToBottom() {
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function requestResize() {
    // Calculate needed height: chat-box content + padding
    requestAnimationFrame(() => {
      const chatBox = document.querySelector('.chat-box');
      const contentHeight = chatBox.scrollHeight + 16; // 8px padding top+bottom
      const minHeight = 72;
      const needed = Math.max(minHeight, contentHeight);
      planlyApi.resizeChat(needed);
    });
  }

  function escapeHtml(str) {
    if (typeof str !== 'string') return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ─── Error reporting (issue 5a) ─────────────────────────
  function reportError(context, err) {
    const msg = (err && typeof err === 'object' && err.message) ? err.message : String(err);
    console.error('[' + context + ']', msg);
    try { planlyApi.reportError(context, msg); } catch (_) {}
  }

  // ─── Initial focus ──────────────────────────────────────
  inputField.focus();
  requestResize();
  // ═══════════════════════════════════════════════════════
  // WindowManager — handles drag & resize event flows
  // ═══════════════════════════════════════════════════════
  //
  // Event flow — Drag:
  //   pointerdown on .drag-handle
  //   → capture pointer, record start screen coords
  //   → pointermove: compute delta, call planly.moveWindow(dx, dy)
  //   → pointerup/pointercancel: release capture, persist bounds
  //
  // Event flow — Resize:
  //   pointerdown on .resize-handle[data-direction]
  //   → capture pointer, record start coords + start bounds
  //   → pointermove: compute delta per direction axes,
  //     send new bounds via planly.setWindowBounds(...)
  //   → pointerup/pointercancel: release, persist bounds
  //
  // Edge cases handled:
  //   • Pointer capture prevents events leaking to iframes / external windows
  //   • Bounds clamped to screen work area (server-side in main.ts)
  //   • Min/max constraints enforced both client-side and Electron-side
  //   • Keyboard arrow keys move the window when drag handle is focused
  //   • High-DPI: all coordinates are in logical (CSS) pixels — Electron
  //     handles DPR mapping internally via screen.getPrimaryDisplay()
  //   • Stale/offscreen persisted values are corrected on restore
  //

  const WindowManager = (() => {
    const KEYBOARD_MOVE_STEP = 20; // px per arrow key press

    // ─── Drag state ──────────────────────────
    let isDragging = false;
    let dragStartScreenX = 0;
    let dragStartScreenY = 0;

    // ─── Resize state ────────────────────────
    let isResizing = false;
    let resizeDir = '';
    let resizeStartScreenX = 0;
    let resizeStartScreenY = 0;
    let resizeStartBounds = { x: 0, y: 0, width: 0, height: 0 };
    let constraints = { minWidth: 360, maxWidth: 960, minHeight: 72, maxHeight: 1200 };

    // Load constraints from main process
    async function loadConstraints() {
      try {
        constraints = await planlyApi.getWindowConstraints();
      } catch (_) {}
    }
    loadConstraints();

    // ─── Drag logic ──────────────────────────

    const dragHandle = document.getElementById('dragHandle');

    function onDragStart(e) {
      // Only primary button
      if (e.button !== 0) return;
      // Don't start drag from interactive children (there shouldn't be any, but safety)
      if (e.target !== dragHandle && !dragHandle.contains(e.target)) return;

      isDragging = true;
      dragStartScreenX = e.screenX;
      dragStartScreenY = e.screenY;

      dragHandle.setPointerCapture(e.pointerId);
      dragHandle.style.cursor = 'grabbing';
      document.body.style.userSelect = 'none';

      e.preventDefault();
    }

    function onDragMove(e) {
      if (!isDragging) return;

      const dx = e.screenX - dragStartScreenX;
      const dy = e.screenY - dragStartScreenY;

      if (dx !== 0 || dy !== 0) {
        planlyApi.moveWindow(dx, dy);
        dragStartScreenX = e.screenX;
        dragStartScreenY = e.screenY;
      }
    }

    function onDragEnd(e) {
      if (!isDragging) return;
      isDragging = false;

      try { dragHandle.releasePointerCapture(e.pointerId); } catch (_) {}
      dragHandle.style.cursor = '';
      document.body.style.userSelect = '';

      planlyApi.saveWindowBounds();
    }

    dragHandle.addEventListener('pointerdown', onDragStart);
    dragHandle.addEventListener('pointermove', onDragMove);
    dragHandle.addEventListener('pointerup', onDragEnd);
    dragHandle.addEventListener('pointercancel', onDragEnd);

    // ─── Keyboard accessibility for drag handle ──

    dragHandle.addEventListener('keydown', (e) => {
      let dx = 0, dy = 0;
      switch (e.key) {
        case 'ArrowLeft':  dx = -KEYBOARD_MOVE_STEP; break;
        case 'ArrowRight': dx = KEYBOARD_MOVE_STEP; break;
        case 'ArrowUp':    dy = -KEYBOARD_MOVE_STEP; break;
        case 'ArrowDown':  dy = KEYBOARD_MOVE_STEP; break;
        default: return;
      }
      e.preventDefault();
      planlyApi.moveWindow(dx, dy);
      planlyApi.saveWindowBounds();
    });

    // ─── Resize logic ────────────────────────

    const resizeHandles = document.querySelectorAll('.resize-handle');

    async function onResizeStart(e) {
      if (e.button !== 0) return;

      const dir = e.currentTarget.dataset.direction;
      if (!dir) return;

      isResizing = true;
      resizeDir = dir;
      resizeStartScreenX = e.screenX;
      resizeStartScreenY = e.screenY;

      try {
        const bounds = await planlyApi.getWindowBounds();
        if (bounds) resizeStartBounds = { ...bounds };
      } catch (_) {}

      e.currentTarget.setPointerCapture(e.pointerId);
      document.body.style.userSelect = 'none';
      e.preventDefault();
    }

    function onResizeMove(e) {
      if (!isResizing) return;

      const dx = e.screenX - resizeStartScreenX;
      const dy = e.screenY - resizeStartScreenY;

      let { x, y, width, height } = resizeStartBounds;

      // Compute new bounds based on resize direction
      if (resizeDir.includes('e')) {
        width = resizeStartBounds.width + dx;
      }
      if (resizeDir.includes('w')) {
        width = resizeStartBounds.width - dx;
        x = resizeStartBounds.x + dx;
      }
      if (resizeDir.includes('s')) {
        height = resizeStartBounds.height + dy;
      }
      if (resizeDir.includes('n')) {
        height = resizeStartBounds.height - dy;
        y = resizeStartBounds.y + dy;
      }

      // Client-side clamp (main process also clamps)
      width = Math.max(constraints.minWidth, Math.min(width, constraints.maxWidth));
      height = Math.max(constraints.minHeight, Math.min(height, constraints.maxHeight));

      // If width was clamped on the west side, fix x
      if (resizeDir.includes('w')) {
        x = resizeStartBounds.x + resizeStartBounds.width - width;
      }
      // If height was clamped on the north side, fix y
      if (resizeDir.includes('n')) {
        y = resizeStartBounds.y + resizeStartBounds.height - height;
      }

      planlyApi.setWindowBounds({ x: Math.round(x), y: Math.round(y), width: Math.round(width), height: Math.round(height) });
    }

    function onResizeEnd(e) {
      if (!isResizing) return;
      isResizing = false;
      resizeDir = '';

      try { e.currentTarget.releasePointerCapture(e.pointerId); } catch (_) {}
      document.body.style.userSelect = '';

      planlyApi.saveWindowBounds();
    }

    resizeHandles.forEach((handle) => {
      handle.addEventListener('pointerdown', onResizeStart);
      handle.addEventListener('pointermove', onResizeMove);
      handle.addEventListener('pointerup', onResizeEnd);
      handle.addEventListener('pointercancel', onResizeEnd);
    });

    // ─── Prevent drag/resize from inner controls ──
    // The pointer capture approach already prevents this:
    // pointerdown only fires on .drag-handle / .resize-handle elements,
    // so clicks on inputs, buttons, messages etc. behave normally.

    return { loadConstraints };
  })();</script>

</body>
</html>